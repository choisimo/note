소년 빌게이츠는 MergeSort를 공부하고 재미 있어서 O(nlogn)으로 정렬하는 다른 알고리즘을 찾았다. 그 중 QuickSort는 다음과 같다.

A[p..r]를 정렬해주는 함수 quickSort가 있다고 가정한다.

A[p..r]에서 기준 원소를 중심으로 대소를 분류 후, 그 기준 원소의 위치를 q라 하자.( partition )

2.1 기준 원소를 항상 배열의 마지막 위치에 있는 원소로 선택한다.

A[p..q-1]와 A[q+1...r]에 대해서 다시 1의 quickSort를 수행한다.

여기서는 partition을 할 때, 배열 내 원소들 사이의 교환 회수를 계산하여 출력한다. 이 때 퀵소트는 빌게이츠가 배운대로 구현되어야 한다. 빌게이츠가 배운 partition 방법은 다음과 같다.

partition(A[], p, r)
{
   x = A[r];
   i = p - 1;
   for j = p to r - 1
      if(A[j] <= x) then A[++i] ↔ A[j];
   A[i+1] ↔ A[r];
   return i + 1;
}
※ 책과 다른 partition 방법을 쓰면 정렬은 되나 교환 회수가 다르게 나타날 수 있습니다. 문제의 명확성을 위해서 책에 나온 partition을 써놓았고, 문제의 조건을 수정하였습니다. 불편을 끼쳐드려 죄송합니다.

※ 책 : 쉽게 배우는 알고리즘 관계 중심의 사고법 - 문병로 지음

입력
첫 줄에는 정렬해야 하는 원소의 개수 n(1<=n<=10000)이 들어 온다.

그 다음 줄에는 n개의 임의의 정수가 들어온다. 이 때 각 정수는 서로 다른 값을 가진다.

출력
오름차순으로 정렬할 때, 배열 내 원소들 사이의 교환 회수를 출력한다.

예제 입력 1
10
4 3 7 8 0 5 2 1 6 9
예제 출력 1
24