## 기수 정렬 (Radix Sort)

### 1. 개요
- 비교(Comparison)에 의존하지 않고 자릿수(Digit) 혹은 문자 Position을 기반으로 정렬하는 **비교 불필요 정렬(Non-comparison Sort)**.
- 가장 낮은 자리(LSD: Least Significant Digit)부터 높은 자리(MSD: Most Significant Digit)까지 순차적으로 안정 정렬(Stable Sort)을 반복하여 전체 순서를 확정.
- 정수, 고정 길이 문자열(예: 학번, 우편번호), 전화번호, 주민번호 등 자릿수/포맷이 일정한 데이터에서 매우 효율적.
- 핵심 요건: 자리수별 정렬에 사용하는 내부 정렬 알고리즘은 반드시 **Stable** 해야 한다. (Counting Sort, Stable 버전의 Bucket, 또는 Stable한 Insertion 변형 등)

### 2. 왜 안정 정렬이 필수인가?
아래와 같이 두 단계(일의 자리 -> 십의 자리)로 정렬한다고 할 때, 첫 단계에서 형성된 상대적 순서가 두 번째 단계 이후에도 유지되어야 전체 자릿수 관점의 올바른 순서가 나온다.
- 만약 중간 단계에서 순서가 뒤섞이면 이전에 반영해 둔 낮은 자리의 정보가 무효화 → 최종 정렬 실패.

### 3. 시간/공간 복잡도
- 시간: O(k * n)  (k = 최대 자릿수, n = 원소 개수)
  - 각 자릿수마다 O(n) 안정 정렬 1회 수행 → k번 반복.
  - k가 log_{10}(M) (M은 최대값) 정도로 작을 때 사실상 선형에 가까운 성능.
- 공간: O(n + b) (b = 기수(Base): 10진수면 10, 16진수면 16 등) + 안정 정렬 알고리즘 추가 메모리.
- 비교 기반 하한 O(n log n) 을 피할 수 있는 이유: 비교를 통한 순서 판별이 아닌 “자릿수 분류(classification)”를 사용하기 때문.

### 4. 적용 시 유리/불리 조건
| 구분 | 유리 | 불리 |
|------|------|------|
| 데이터 형태 | 고정 길이 정수/문자열 | 길이 제각각 문자열 |
| 값의 범위 | 자릿수 길이 제한 | 매우 큰 자릿수(k가 큼) |
| 메모리 | 충분한 추가 버퍼 가능 | 메모리 매우 제한 |
| 안정성 요구 | 필요/중요 | 필요 없고 단순 In-place 원할 때 |

### 5. LSD vs MSD Radix
| 전략 | LSD (Least Significant Digit) | MSD (Most Significant Digit) |
|------|-----------------------------|------------------------------|
| 처리 순서 | 낮은 자리 → 높은 자리 | 높은 자리 → 낮은 자리 (재귀/분할) |
| 구현 난이도 | 단순, 반복 루프 | 상대적으로 복잡 (부분 배열 재귀) |
| 안정 정렬 필요성 | 매우 중요 | 부분 배열 독립 정렬 시 안정 ↓ (그러나 대부분 유지 권장) |
| 가변 길이 문자열 | 처리 까다롭 (패딩 필요) | 앞자리 다르면 빠른 분할 가능 |

일반적인 정수 정렬 교육/실습에서는 LSD 방식 + Counting Sort를 가장 널리 사용.

### 6. 기본 Pseudocode (LSD)
```text
radixSort(A, n, k):            # k: 최대 자릿수 (1-based: 1=일의 자리)
  for d from 1 to k:
    stableCountingByDigit(A, n, d)
```
- `stableCountingByDigit` 는 (1) 해당 자리수 추출 → (2) 빈도 계산 → (3) 누적합 → (4) 뒤에서 앞으로 순회하여 안정적으로 재배치.

### 7. 자릿수 추출
정수 x, d번째(1=일의 자리) 자릿수 digit_d(x):
```
(x // 10^(d-1)) % 10
```

### 8. 큐/버킷 구현 관점
Counting Sort 대신 0~9 버킷(Queue) 배열을 두고 한 자릿수 라운드마다:
1. 모든 원소 스캔하며 해당 버킷에 Enqueue (O(n))
2. 버킷 0 → 9 순서로 Dequeue 하여 다시 A에 덮어씀 (O(n))
- Queue(FIFO)를 사용해야 안정성 보장.

### 9. 작은 예시 (LSD)
초기: 50, 64, 15, 25, 27, 17, 28, 39
1) 1의 자리 정렬 (버킷):
- 0: 50
- 4: 64
- 5: 15, 25
- 7: 27, 17
- 8: 28
- 9: 39
결합 결과: [50, 64, 15, 25, 27, 17, 28, 39] (우연히 동일 순서 유지)
2) 10의 자리 정렬:
- 1의 자리 정렬 결과를 그대로 사용하여 10의 자리 기준 버킷에 재분배
- 1x: 15, 17
- 2x: 25, 27, 28
- 3x: 39
- 5x: 50
- 6x: 64
결과: [15, 17, 25, 27, 28, 39, 50, 64]

### 10. Counting Sort로 한 자릿수 정렬하기 (Stable)
```text
stableCountingByDigit(A, n, d):
  count[0..9] <- 0
  for i in 0..n-1:
    digit <- extractDigit(A[i], d)
    count[digit]++

  # 누적합 → 위치 계산
  for v in 1..9:
    count[v] += count[v-1]

  B[0..n-1]
  # 뒤에서 앞으로: 안정성
  for i in (n-1) downto 0:
    digit <- extractDigit(A[i], d)
    count[digit]--
    B[count[digit]] <- A[i]

  copy B -> A
```

### 11. 복잡도 실제 해석 예
- n = 1,000,000, 최대값 < 1,000,000 (k = 6) → O(6n) ≈ 6,000,000 기본 연산 + Counting Sort 내부 상수.
- 같은 입력을 비교 정렬로 하면 O(n log n) ≈ 1e6 * ~20 ≈ 20,000,000 비교. → Radix 유리.

### 12. Radix Sort 한계/주의
| 이슈 | 설명 | 대응 |
|------|------|------|
| 음수 처리 | 단순 LSD 구현은 음수/양수 혼재시 바로 적용 어려움 | 부호 분리(음수 절댓값 정렬 후 역순 병합) |
| 매우 큰 k | 자릿수 라운드 증가로 이득 상실 | Base 확장 (예: 2^8=256 단위) 로 라운드 감소 |
| 메모리 | B 배열 + count 배열 필요 | In-place 연구 있으나 구현 복잡/비권장 |
| 캐시 비효율 | 큰 Base + 다수 패스시 메모리 점프 | 적절한 Base(64~256) 튜닝 |
| 가변 길이 문자열 | 패딩 필요(LSD) | MSD 방식 + 길이 우선 비교 또는 sentinel |

### 13. Base(기수) 선택 전략
- Base 너무 작으면 (10) → 패스(k)가 많음.
- Base 너무 크면 (65536) → count 배열 커지고 캐시 미스 증가.
- 32~256 범위(바이트 혹은 그 배수) 선택이 실무 구현에서 자주 사용 (예: Radix sort for 32-bit integer: 8비트씩 4패스).

### 14. Counting Sort 복습 (부분 확장)
주어진 예: [5, 11, 7, 10, 11, 6, 8, 2, 12, 8, 8, 10, 2, 1, 0]
1) 빈도수 수집 → count
2) 누적합 → prefix sum (≤ 값 개수)
3) 뒤에서 앞으로 순회하며 안정 재배치
- 누적합 c[10] = 12 → 값 10이 배치될 최종 끝 index = 11 (0-based) 이후 감소.

### 15. Bucket Sort / 계수 버킷과의 관계
- Bucket Sort: (0,1) 실수 균등 분포 가정 → 값 * n 으로 버킷 인덱스 매핑 → 각 버킷 내부 소규모 정렬(Insertion 등) → 평균 O(n).
- Radix Sort: 자릿수 분해를 이용한 결정적 분류. 분포 가정 불필요.
- 계수 버킷(Counting + Bucket 혼합): 정수부 먼저 Counting/버킷으로 묶고, 소수부/세부 필드에 Insertion 등 적용 → 부분 정렬된 상태 활용.

### 16. 힙 정렬 vs 병합 정렬 (참고 재구성)
| 항목 | 힙 정렬 | 병합 정렬 |
|------|--------|-----------|
| 시간복잡도 | 항상 O(n log n) | 항상 O(n log n) |
| 추가 메모리 | O(1) (in-place) | O(n) temp 배열 |
| 캐시 지역성 | 낮음 (트리 점프) | 높음 (연속 배열) |
| 안정성 | 기본 비안정 | 구현 따라 Stable 가능(추가비용) |
| 실제 성능 | 상수 계수 큼 | 실무에서 더 빠른 경우 다수 |

### 17. 정리 포인트
- Radix Sort는 값 자체를 ‘비교’하지 않고 자릿수 ‘분류’를 반복.
- 안정 정렬 유지가 전제.
- k가 충분히 작고(또는 Base 최적화) n이 매우 클수록 비교 기반 정렬 대비 우위.
- 음수/가변 길이/메모리 제약은 설계 시 별도 처리 필요.

---
(End of Radix Sort 확장)
