## 기수 정렬 (Radix Sort) 
- 비교 기반 정렬이 아닌 알고리즘
- 데이터의 자릿 수(digit) 또는 문자의 위치 (position)를 기준으로 정렬
- 보통 일의 자리 -> 십의 자리 -> 백의 자리 순으로 정렬

- 시간 복잡도 : O(k * n) ( k는 최대 자릿 수, n은 원소의 개수)
  - (예시) 235 -> k = 3 (3자리 수), n = 1000 (1000개의 원소)
- 정수/문자열 같은 자릿수 제한 데이터에 효과적임
- 추가 메모리 필요
- **안정 정렬 (stable sort)** 
  - 값이 같은 원소들의 상대적 순서가 정렬 전후에 유지됨
  - (예시) [1,5,3,4,6,7] -> [1,3,4,5,6,7] (5와 6의 순서 유지) 
    - 5는 6보다 항상 앞에 있음 
    - Radix Sort는 안정정렬 충족해야함
        - why -> 자릿수별로 정렬할 때, 앞서 정렬된 자릿수의 순서가 유지되어야 하기 때문
        - if 안정 정렬이 아니라면 -> 앞서 정렬한 자릿수의 순서가 변경되므로 정렬을 보장할 수 없음

## 기수 정렬 작동 과정
1. 가장 낮은 자릿수부터 시작하여 각 자릿수별로 안정 정렬 수행 
    - 단, 앞서 정렬된 자릿수의 순서가 유지되어야 함

### Pseudo Code
```bash
radixSort(A[], n, k):
    for d from 1 -> k do:                       # k 는 자릿 수 (낮은 자릿 수부터 시작함)
        stableSortByDigit(A[], n, d) 
```
- 0 ~ 9 까지 표시된 10개의 리스트 할당 
    - 각 리스트는 Queue 구조 : FIFO (First In First Out) 구조 적용 
        - Queue 구조 사용 이유 : 정렬 순서 유지를 위함
    - 리스트는 자릿수 숫자와 매칭. 즉, 리스트 0부터 시작하여 
    저장된 값들을 자릿 수 숫자에 따라 순차적으로 배열에 삽입
    - n 개으ㅢ 원소들에 대해 탐색 & 삽입 (Big O(n))


자릿수 (Queue)
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
|---|---|---|---|---|---|---|---|---|---|
|   |   |   |   |   |   |   |   |   |   |
|---|---|---|---|---|---|---|---|---|---|

초기 : 50, 64, 15, 25, 27, 17, 28, 39
1. 일의 자릿 수 정렬하기 
- 일의 자릿 수 기준으로 각 숫자를 해당 값의 리스트에 삽입
- 중복 값 존재 시에는 앞서 삽입된 값이 먼저 나오도록 함 (안정 정렬)

일의 자릿수 : 50, 64, 15, 25, 27, 17, 28, 39

| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
|---|---|---|---|---|---|---|---|---|---|

|---|---|---|---|---|---|---|---|---|---|

### 자릿 수 (digit) 계산
- 정수 나눗셈과 나머지 연산 (%) 을 사용
- x / (10 ^ (d - 1)) : 구하고자 하는 자릿수가 1의 자리에 오도록 정수 나눗셈 수행

### Counting Sort
- 비교하지 않는 정렬 알고리즘
- 원소들의 범위를 이용하여 빈도 수를 세고, 이를 기반으로 정렬
- 시간 복잡도: O(n + k) (n은 데이터 개수, k 는 데이터 범위


#### 원소 범위가 0 ~ 12 인 정렬 문제
[5, 11, 7, 10, 11, 6, 8, 2, 12, 8, 8, 10, 2, 1, 0]

1. 0 ~12 까지의 각 값의 빈도수를 별도 배열에 저장 (c 배열 - counting array)
- 공간 복잡도 : O(k) (k는 데이터 범위)
- 빈도 수 

    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]

    [1, 1, 2, 0, 0, 1, 1, 1, 3, 0, 2, 2, 1] -> c 배열

2. 누적 빈도수 계산
- c[10] 은 10 이하의 값이 몇 개인지 나타냄 (c[10] = 12)
- 10 이하의 값이 12개 라는 의미 - 각 배열의 index 의 원소 값이 아닌 빈도 수
- c 배열을 누적합으로 변환
    - c[i] = c[i] + c[i - 1] (i = 1 ~ k) 

|index| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 |
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|빈도 수|1|1|2|0|0|1|1|1|3|0|2|2|1|
||

| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 |
|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|
|1|1 + 1|2 + 1 + 1| 0 + 2 + 1 + 1|1 + 0 + 2 + 1 + 1||1 + 1 + 0 + 2 + 1 + 1|1 + 1 + 1 + 0 + 2 + 1 + 1|3 + 1 + 1 + 1 + 0 + 2 + 1 + 1|0 + 3 + 1 + 1 + 1 + 0 + 2 + 1 + 1|2 + 0 + 3 + 1 + 1 + 1 + 0 + 2 + 1 + 1|2 + 2 + 0 + 3 + 1 + 1 + 1 + 0 + 2 + 1 + 1|1+2+2+0+3+1+1+1+0+2+1+1|
|누적합|1|2|4|4|4|5|6|7|10|10|12|14|15|

3. 누적합 토대로 각 원소 배치
- 별도의 배열 B[] 에 정렬된 결과 저장
- C[10] 값은 10원소가 배칠될 수있는 끝 index 
  - 10 값의 원소 배치시 C[10] - 1 의 index 에 배치
  - 그리고 C[10] 값 1 감소 (다음 10 값이 중복되지 않고 배치되도록 함)


## 버킷 정렬
  - 시간복잡도, 공간복잡도, pseudo code 는 간단하게 확인
  - 배열 index 개수만큼 버킷 생성 
  - 정수부 값만 사용, 버킷 개수 = 배열 index 개수
  - 곱셈 값 ()

## 계수 버킷 정렬
- 장점 : 정수부를 한 번 정렬했기에 삽입 정렬만 사용하는 것보다 훨씬 빠름 (부분적으로 정렬된 상태이므로 최선의 상태에 가까움을 가정하여 삽입 정렬 수행)


---
### [참고] 힙 정렬 vs 병합 정렬
- 일반적으로 힙 정렬이 병합 정렬보다 느림
- 메모리 접근 패턴 (캐시 지역성)
  - 힙 정렬 : 트리 구조로 인해 메모리 접근이 비연속적
  - 병합 정렬 : 배열 기반으로 연속적인 메모리 접근
- 비교 횟수 차이 
  - 힙 정렬 : 평균적으로 더 많은 비교 수행
    - 2 * n * log(n) 비교 : 병합 정렬의 약 2배
  - 병합 정렬 : 비교 횟수가 상대적으로 적음
    - n * log(n) 비교
