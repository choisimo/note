## 집합의 처리
- Make_Set : 하나
- Find_Set : 포함한 것 찾기
- Union_Set : 모두 합한 것
Set x 존재 시, Make_Set(y) 으로 Set y 만들고 Union -> x + y

### 뭐로 만듦?
- 연결 리스트 or Tree 구조 사용
**d (대표 노드)** - e -f - g - h 
- e, f, g, h 의 대표 원소는 d 를 ptr (대표 노드에 대한 포인터 지정 
**--> why? 검색 속도를 빠르게 하기 위해서**)

## 연결리스트 
### 생성 
Make_Set(x) -> 대표 노드 생성 시 : 자기 자신을 포인터로 가리킴

#### 두 집합을 합치기
노드 수가 **적은** 연결리스트를 노드 수가 **많은** 연결리스트에 넣는게 효율적이다. 
- why? 포인터 갱신 등 바꿀게 더 적어서 그럼
- 대표 노드의 변경은? 
    - 새로 바뀐 대표 노드로 포인터 하나만 변경하면 됨

### 처리 수행 시간
- Make_Set : 노드 1개만 생성이므로 O(1)
- Find_Set :**대표 노드**만 찾으면 되므로 O(1)
- Union_Set : 작은 집합의 노드 개수에 비례한 시간 복잡도를 가진다.  (즉, case 마다 다르다.)

## 트리 구조
### 생성
- 루트 노드가 대표 노드임 
  - 보통 트리 구조는 **부모가 자식** 포인터로 가리키지만
  - **자식 노드가 부모 노드를 가리키는 점이 차이점**
  - why? 루트 노드 찾으려면 어쩔 수 없음
- 동일하게 **자기 자신을 가리키는 노드**는 **루트 노드**
- Union 할 때, 포인터 하나만 연결시켜주면 됨
  - 더 노드 수가 적은 집합의 루트노드가 연결할 집합의 루트 노드에 연결함 -> if (x = x.parent : 자기 자신을 가리키는 즉, 루트 노드) return 
- 루트 노드를 먼저 찾아 (Find_Set)
- Tree 구조이지만 일반적인 Tree 의 법칙 적용이 안되니 주의 (height 등 적용방식이 다름)

### 트리 사용 시 효율 최적화 방안
#### 랭크(Rank)를 이용한 방식
- 각 노드마다 자신의 높이를 나타내는 정보를 노드에 저장 (서브 트리)
- Tree 의 높이가 낮은 노드를 높이가 높은 트리로 연결 (Rank 는 곧 높이(height)이다.)

#### 경로 압축 방식
- Find_Set 을 실행하는 과정에서 만나는 모든 노드들이 직접 루트를 가리키도록 부모노드에 대한 포인터 갱신함
    - 트리의 높이를 줄일 수 있음 (탐색 시간 감소)
- 하나의 노드로 된 트리는 **Rank = 0**,
- Rank 정보는 Union 할 때만 사용된다.
- 루트 노드의 Rank 정보를 확인, 각 서브트리의 높이를 의미한다.
- Rank 작은 Sets 를 Rank 큰 곳으로 합친다.
- Find_Set 에 **경로 압축** 적용
- Rank 는 정확한 높이가 아닌, 높이의 상한으로 다룸

#### pseudo code
```
Make_Set (x) :
    x.parent <- x
    x.rank <- 0 


# 경로 압축
Find_Set (X) : 
    if (x != x.parent.)

# 주의점 : 높이가 같은 것을 합치게 되면 루트 노드의 rank 값이 1 증가한다.
Union (x, y) :
    

```
랭크를 이용한 Union 를 사용하면, 랭크가 k인 노드를 대표로 하는 집합의 원소 수는 최소한 2개이다.

#### 귀납법
- Rank 0 이면 원소가 1개
- Rank 가 r 이면, 최소한 2  ^ r  개의 원소
- Rank 가 r + 1 

#### 주의
