---------------------------------------------
1. null은 주소값을 가지지 않지만, null을 체크할 때는 '==' 를 사용함
- null은 객체가 아니므로 메모리 주소 또한 존재하지 않는데 어떻게 '==' 연산자로 비교 가능한가?
---------------------------------------------

---------------------------------------------
2. extends 는 클래스 상속, implements 는 인터페이스 상속이므로, 각각 단일 상속, 다중 상속 가능하다. class child1 extends parent1 implements human 의 순서에서 class 상속이 단일 상속임에 따라 우선적으로 1. extends 작성 2. implements 작성 순서를 가지지만, 만약 인터페이스 또한 단일 상속한다면 순서는 상관없지 않은가? 왜 각각 단일 상속시에도 컴파일 에러가 발생하는가?
---------------------------------------------

---------------------------------------------
3.무명 클래스의 리스너 객체를 new으로 생성할 때, 이 객체는 new 키워드를 사용함에 따라 힙 메모리 영역에 할당되는데, 자바에서 무명 클래스는 보통 일회성으로 사용되는 클래스이다. 잃회성 이라면 stack 영역에 다 넣어도 상관없지 않은가?
(속도 차이가 심함에도 불구하고 힙 영역을 사용하는 class 를 굳이 사용해야 하는가?)

그리고 만약에 무명 클래스 구조를 반복 호출 때 메서드 메모리 영역에서 구조를 받아 힙에 객체를 생성할 때에 클래스 구조의 효율적 사용이 가능하다고 할 때,
무명 클래스가 아닌 외부 클래스에서도 이 메서드 영역의 메타 데이터를 사용한 빠른 동적 할당이 가능한가?
-> '무명' 이므로 불가하다고 판단되는 경우
--> 그렇다면 무명 클래스마다 각각 독립적인 클래스으로써 각각의 메타데이터를 메서드 영역에 저장한다고 가정된다면, 어떠한 이점이 있다고 볼 수 있는가?
---------------------------------------------

---------------------------------------------
4. computing 상에서의 y 좌표는 현실의 계산과 reversed 된 방향으로 증감한다.
이는 초기 컴퓨팅 장비의 특성상 (CRT) 진공관 내부의 전자를 방출시켜 형광면에 충돌시킴으로써 가시광선을 발생시켜
화면에 띄워주는 특성에 기인한 것이라 할 때에 이러한 특징이 "양자역학에서의 빛은 모든 가능한 경로로 이동한다." 라는 관찰에서 다소 이상한 의문을 품게한다.
-> 보통 위에서 아래로 읽는 사람들의 특성에 맞춰 설계되었다고 가정한다면 또 다른 의문이 생긴다.
--> 광원의 속도는 구분 불가능할 정도로 엄청나게 빠르다.
당시 컴퓨팅 성능의 한계상 이미지와 같은 느리게 연산처리되는 정보를 위에서 아래로 나타내주는 것이 심리학적인 안정감을 주기에 그렇게 설계되었다는 결론을 내게된다.
---------------------------------------------

---------------------------------------------
5. 자바의 같은 패키지 내에서 import 으로 외부 클래스를 이용할 때에 단일 class 파일에 대해서 동시에 여러 쓰레드가 접근할 경우가 생긴다면 충돌(일관성 문제 등)하는 문제점이 발생할 수 있을 것 같은데, 어떻게 이를 해결하는가? (멀티 스레드 환경에서 단일 클래스에 대한 다중 접근 방식에 따른 일관성을 관리하는 방법)
---------------------------------------------

---------------------------------------------
6. NullPointerException 에 대해서
Ractangle[] r = new Ractangle[100]; 선언시에
모든 index 를 초기화하지 않는다면 접근시에 null 값 지정으로 인한 오류가 발생한다.
-> 이 경우에는 힙 영역에 메모리 공간만을 생성하고, 아직 객체를 할당하지 않았기 때문에 반드시 new Ractangle 을 명시적으로 각 배열 힙 메모리 영역에 할당해주어야 NullPointerException 이 발생하지 않는다.
---------------------------------------------

---------------------------------------------
7. 클래스 로더에서 class 파일을 로딩하는 순서는
- 1. Loading (load) : 클래스 파일을 가져와서 JVM 메모리에 로드한다.
- 2. Linking (링크) : 클래스 파일을 사용하기 위해 검증하는 과정이다.
- 3. Initialization (초기화) : 클래스 변수들을 적절한 값으로 초기화한다.
---------------------------------------------

